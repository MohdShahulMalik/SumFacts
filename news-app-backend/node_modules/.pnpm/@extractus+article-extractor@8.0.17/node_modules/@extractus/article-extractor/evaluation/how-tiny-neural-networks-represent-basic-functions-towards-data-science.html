<div>
<h2>Introduction</h2>
<p>This article shows how small Artificial Neural Networks (NN) can represent basic functions. The goal is to provide fundamental intuition about how NNs work and to serve as a gentle introduction to <a target="_blank" href="https://transformer-circuits.pub/2022/mech-interp-essay/index.html">Mechanistic Interpretability</a> – a field that seeks to reverse engineer NNs.</p>
<p>I present three examples of elementary functions, describe each using a simple algorithm, and show how the algorithm can be "coded" into the weights of a neural network. Then, I explore if the network can learn the algorithm using backpropagation. I encourage readers to think about each example as a riddle and take a minute before reading the solution.</p>
<h2>Machine Learning Topology</h2>
<p>This article attempts to break NNs into discrete operations and describe them as algorithms. An alternative approach, perhaps more common and natural, is looking at the continuous topological interpretations of the linear transformations in different layers.</p>
<p>The following are some great resources for strengthening your topological intuition:</p>
<ul>
<li><a target="_blank" href="https://playground.tensorflow.org/#activation=tanh&amp;batchSize=10&amp;dataset=circle&amp;regDataset=reg-plane&amp;learningRate=0.03&amp;regularizationRate=0&amp;noise=0&amp;networkShape=4,2&amp;seed=0.91521&amp;showTestData=false&amp;discretize=false&amp;percTrainData=50&amp;x=true&amp;y=true&amp;xTimesY=false&amp;xSquared=false&amp;ySquared=false&amp;cosX=false&amp;sinX=false&amp;cosY=false&amp;sinY=false&amp;collectStats=false&amp;problem=classification&amp;initZero=false&amp;hideText=false">Tensorflow Playground</a> – a simple tool for building basic intuition on classification tasks.</li>
<li><a target="_blank" href="https://cs.stanford.edu/people/karpathy/convnetjs//demo/classify2d.html">ConvnetJS Demo</a> – a more sophisticated tool for visualizing NNs for classification tasks.</li>
<li><a target="_blank" href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/">Neural Networks, Manifolds, and Topology</a> – a great article for building topological intuition of how NNs work.</li>
</ul>
<h2>Three Elementary Functions</h2>
<p>In all the following examples, I use the terminology "neuron" for a single node in the NN computation graph. Each neuron can be used only once (no cycles; e.g., not RNN), and it performs 3 operations in the following order:</p>
<ol>
<li>Inner product with the input vector.</li>
<li>Adding a bias term.</li>
<li>Running a (non-linear) activation function.</li>
</ol>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg.png" alt="" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg.png 1712w, https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg-300x101.png 300w, https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg-1024x346.png 1024w, https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg-768x260.png 768w, https://towardsdatascience.com/wp-content/uploads/2024/09/1Ix7ndz7IMgOh24E803u7Bg-1536x519.png 1536w" /></figure>
<p>I provide only minimal code snippets so that reading will be fluent. This <a target="_blank" href="https://colab.research.google.com/drive/1zt9lVUH9jH2zx5nsFA_4Taq6Ic-ve09C?usp=sharing">Colab notebook</a> includes the entire code.</p>
<h2>The &lt; operator</h2>
<p>How many neurons are required to learn the function "x &lt; 10"? Write an NN that returns 1 when the input is smaller than 10 and 0 otherwise.</p>
<h3>Solution</h3>
<p>Let’s start by creating sample dataset that follows the pattern we want to learn</p>
<pre><code>X = [[i] for i in range(-20, 40)]
Y = [1 if z[0] &lt; 10 else 0 for z in X]</code></pre>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1pgHXwhFh-8DNrydo7N6J5w.png" alt="Creating and visualizing the training data for &quot;&lt; operator&quot;" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1pgHXwhFh-8DNrydo7N6J5w.png 547w, https://towardsdatascience.com/wp-content/uploads/2024/09/1pgHXwhFh-8DNrydo7N6J5w-300x237.png 300w" /><figcaption>Creating and visualizing the training data for "&lt; operator"</figcaption></figure>
<p>This classification task can be solved using <a target="_blank" href="https://en.wikipedia.org/wiki/Logistic_regression">logistic regression</a> and a <a target="_blank" href="https://en.wikipedia.org/wiki/Sigmoid_function">Sigmoid</a> as the output activation. Using a single neuron, we can write the function as <em>Sigmoid(ax+b)</em>. <em>b</em>, the bias term, can be thought of as the neuron’s threshold. Intuitively, we can set <em>b = 10</em> and <em>a = -1</em> and get F=Sigmoid(10-x)</p>
<p>Let’s implement and run F using PyTorch</p>
<pre><code>model = nn.Sequential(nn.Linear(1,1), nn.Sigmoid())
d = model.state_dict()
d["0.weight"] = torch.tensor([[-1]]).float()
d['0.bias'] = torch.tensor([10]).float()
model.load_state_dict(d)
y_pred = model(x).detach().reshape(-1)</code></pre>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1giPlOH6zYhwqsAeS571g2A.png" alt="Sigmoid(10-x)" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1giPlOH6zYhwqsAeS571g2A.png 523w, https://towardsdatascience.com/wp-content/uploads/2024/09/1giPlOH6zYhwqsAeS571g2A-300x231.png 300w" /><figcaption>Sigmoid(10-x)</figcaption></figure>
<p>Seems like the right pattern, but can we make a tighter approximation? For example, F(9.5) = 0.62, we prefer it to be closer to 1.</p>
<p>For the Sigmoid function, as the input approaches -∞ / ∞ the output approaches 0 / 1 respectively. Therefore, we need to make our 10 – x function return large numbers, which can be done by multiplying it by a larger number, say 100, to get F=Sigmoid(100(10-x)), now we’ll get F(9.5) =~1.</p>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1utPwNwrRjupSltXk3pgrBQ.png" alt="Sigmoid(100(10-x))" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1utPwNwrRjupSltXk3pgrBQ.png 557w, https://towardsdatascience.com/wp-content/uploads/2024/09/1utPwNwrRjupSltXk3pgrBQ-300x236.png 300w" /><figcaption>Sigmoid(100(10-x))</figcaption></figure>
<p>Indeed, when training a network with one neuron, it converges to F=Sigmoid(M(10-x)), where M is a scalar that keeps growing during training to make the approximation tighter.</p>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1wqoCajkfvVv_emYmXpdKbg.png" alt="Tensorboard graph - the X-axis represents the number of training epochs and the Y-axis represents the value of the bias and the weight of the network. The bias and the weight increase/decrease in reverse proportion. That is, the network can be written as M(10-x) where M is a parameter that keeps growing during training." srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1wqoCajkfvVv_emYmXpdKbg.png 1346w, https://towardsdatascience.com/wp-content/uploads/2024/09/1wqoCajkfvVv_emYmXpdKbg-300x125.png 300w, https://towardsdatascience.com/wp-content/uploads/2024/09/1wqoCajkfvVv_emYmXpdKbg-1024x428.png 1024w, https://towardsdatascience.com/wp-content/uploads/2024/09/1wqoCajkfvVv_emYmXpdKbg-768x321.png 768w" /><figcaption>Tensorboard graph – the X-axis represents the number of training epochs and the Y-axis represents the value of the bias and the weight of the network. The bias and the weight increase/decrease in reverse proportion. That is, the network can be written as M(10-x) where M is a parameter that keeps growing during training.</figcaption></figure>
<p>To clarify, our single-neuron model is only an approximation of the "&lt;10" function. We will never be able to reach a loss of zero, because the neuron is a continuous function while "&lt;10" is not a continuous function.</p>
<h2>Min(a, b)</h2>
<p>Write a neural network that takes two numbers and returns the minimum between them.</p>
<h3>Solution</h3>
<p>Like before, let’s start by creating a test dataset and visualizing it</p>
<pre><code>X_2D = [
[random.randrange(-50, 50),
 random.randrange(-50, 50)]
 for i in range(1000)
]
Y = [min(a, b) for a, b in X_2D]</code></pre>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1fIO9IROrZJ7ADbKS88CXoQ.png" alt="Visualizing the training data for Min(a, b). The two horizontal axes represent the coordinates of the input. The vertical axis labeled as &quot;Ground Truth&quot; is the expected output - i.e., the minimum of the two input coordinates" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1fIO9IROrZJ7ADbKS88CXoQ.png 389w, https://towardsdatascience.com/wp-content/uploads/2024/09/1fIO9IROrZJ7ADbKS88CXoQ-300x300.png 300w, https://towardsdatascience.com/wp-content/uploads/2024/09/1fIO9IROrZJ7ADbKS88CXoQ-150x150.png 150w" /><figcaption>Visualizing the training data for Min(a, b). The two horizontal axes represent the coordinates of the input. The vertical axis labeled as "Ground Truth" is the expected output – i.e., the minimum of the two input coordinates</figcaption></figure>
<p>In this case, ReLU activation is a good candidate because it is essentially a maximum function (ReLU(x) = max(0, x)). Indeed, using ReLU one can write the min function as follows</p>
<pre><code>min(a, b) = 0.5 (a + b -|a - b|) = 0.5 (a + b - ReLU(b - a) - ReLU(a - b))</code></pre>
<p><em><strong>[Equation 1]</strong></em></p>
<p>Now let’s build a small network that is capable of learning <em>Equation 1</em>, and try to train it using gradient descent</p>
<pre><code>class MinModel(nn.Module):
  def __init__(self):
      super(MinModel, self).__init__()
      # For ReLU(a-b)
      self.fc1 = nn.Linear(2, 1)
      self.relu1 = nn.ReLU()
      # For ReLU(b-a)
      self.fc2 = nn.Linear(2, 1)
      self.relu2 = nn.ReLU()
      # Takes 4 inputs
      # [a, b, ReLU(a-b), ReLU(b-a)]
      self.output_layer = nn.Linear(4, 1)
  def forward(self, x):
      relu_output1 = self.relu1(self.fc1(x))
      relu_output2 = self.relu2(self.fc2(x))
      return self.output_layer(
          torch.cat(
             (x, Relu_output1, relu_output2),
             dim=-1
          )
      )</code></pre>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1U_7qLdHmmgs0H61iHiLRag.png" alt="Visualization of the MinModel computation graph. Drawing was done using the Torchview library" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1U_7qLdHmmgs0H61iHiLRag.png 1158w, https://towardsdatascience.com/wp-content/uploads/2024/09/1U_7qLdHmmgs0H61iHiLRag-300x275.png 300w, https://towardsdatascience.com/wp-content/uploads/2024/09/1U_7qLdHmmgs0H61iHiLRag-1024x940.png 1024w, https://towardsdatascience.com/wp-content/uploads/2024/09/1U_7qLdHmmgs0H61iHiLRag-768x705.png 768w" /><figcaption>Visualization of the MinModel computation graph. Drawing was done using the <a target="_blank" href="https://github.com/mert-kurttutan/torchview">Torchview</a> library</figcaption></figure>
<p>Training for 300 epochs is enough to converge. Let’s look at the model’s parameters</p>
<pre><code>&gt;&gt; for k, v in model.state_dict().items():
&gt;&gt;   print(k, ": ", torch.round(v, decimals=2).numpy())
fc1.weight :  [[-0. -0.]]
fc1.bias :  [0.]
fc2.weight :  [[ 0.71 -0.71]]
fc2.bias :  [-0.]
output_layer.weight :  [[ 1.    0.    0.   -1.41]]
output_layer.bias :  [0.]</code></pre>
<p>Many weights are zeroing out, and we are left with the nicely looking</p>
<pre><code>model([a,b]) = a - 1.41 * 0.71 ReLU(a-b) ≈ a - ReLU(a-b)</code></pre>
<p>This is not the solution we expected, but it is a valid solution and even <strong>cleaner than Equation 1!</strong> By looking at the network we learned a new nicely looking formula! Proof:</p>
<p>Proof:</p>
<ul>
<li>If <em>a &lt;= b: model([a,b]) = a – ReLU(a-b) = a – 0 = a</em></li>
<li>If <em>a &gt; b: a – ReLU(a-b) = a – (a-b) = b</em></li>
</ul>
<h2>Is even?</h2>
<p>Create a neural network that takes an integer x as an input and returns x mod 2. That is, 0 if x is even, 1 if x is odd.</p>
<p>This one looks quite simple, but surprisingly it is impossible to create a finite-size network that correctly classifies each integer in (-∞, ∞) (using a standard non-periodic activation function such as ReLU).</p>
<h3>_<strong>Theorem: is_even needs at least log neurons</strong>_</h3>
<p>_A network with ReLU activations requires at least n neurons to correctly classify each of 2^n consecutive natural numbers as even or odd (i.e., solving is<em>even).</em></p>
<h3><em><strong>Proof: Using Induction</strong></em></h3>
<p><strong>Base: n == 2:</strong> Intuitively, a single neuron (of the form <em>ReLU(ax + b)</em>), cannot solve <em>S = [i + 1, i + 2, i + 3, i + 4]</em> as it is not linearly separable. For example, without loss of generality, assume <em>a &gt; 0</em> and <em>i + 2</em> is even<em>.</em> If <em>ReLU(a(i + 2) + b) = 0,</em> then also <em>ReLU(a(i + 1) + b) = 0</em> (monotonic function)<em>,</em> but <em>i + 1</em> is odd.
More <a target="_blank" href="https://en.wikipedia.org/wiki/Perceptrons_(book)#The_XOR_affair">details</a> are included in the classic Perceptrons book.</p>
<p><strong>Assume for n, and look at n+1:</strong> <em>Let S = [i + 1, …, i + 2^(n + 1)]</em>, and assume, for the sake of contradiction, that <em>S</em> can be solved using a network of size <em>n</em>. Take an input neuron from the first layer <em>f(x) = ReLU(ax + b)</em>, where <em>x</em> is the input to the network. <em>WLOG a &gt; 0</em>. Based on the definition of ReLU there exists a <em>j</em> such that:
<em>S’ = [i + 1, …, i + j], S” = [i + j + 1, …, i + 2^(n + 1)]
f(x ≤ i) = 0
f(x ≥ i) = ax + b</em></p>
<p>There are two cases to consider:</p>
<ul>
<li>Case <em>|S’| ≥ 2^n</em>: dropping <em>f</em> and all its edges won’t change the classification results of the network on S’. Hence, there is a network of size <em>n-1</em> that solves S’. Contradiction.</li>
<li>Case <em>|S”|≥ 2^n</em>: For each neuron <em>g</em> which takes <em>f</em> as an input <em>g(x) =</em> <em>ReLU(cf(x) + d + …) = ReLU(c ReLU(ax + b) + d + …)</em>, Drop the neuron <em>f</em> and wire <em>x</em> directly to <em>g</em>, to get <em>ReLU(cax + cb + d + …)</em>. A network of size <em>n – 1</em> solves <em>S”</em>. Contradiction.</li>
</ul>
<h3>Logarithmic Algorithm</h3>
<p><em>How many neurons are sufficient to classify [1, 2^n]? I have proven that n neurons are necessary. Next, I will show that n neurons are also sufficient.</em></p>
<p>One simple implementation is a network that constantly adds/subtracts 2, and checks if at some point it reaches 0. This will require O(<em>2^n</em>) neurons. A more efficient algorithm is to add/subtract powers of 2, which will require only O(n) neurons. More formally:
_f_i(x) := |x – i|
f(x) := f_1∘ f_1∘ f_2 ∘ f<em>4∘ … ∘ f</em>(2^(n-1)) (|x|)_</p>
<p>Proof:</p>
<ul>
<li>
<p>By definition:<em>∀ x ϵ[0, 2^i]: f</em>(2^(i-1)) (x) ≤ 2^(i-1).
I.e., cuts the interval by half._</p>
</li>
<li>Recursively _f_1∘ f_1∘ f<em>2 ∘ … ∘ f</em>(2^(n-1)) (|x|)_ ≤ 1</li>
<li>For every even _i: is_even(f_i(x)) = is<em>even(x)</em></li>
<li>Similarly _is_even(f_1( f_1(x))) = is<em>even(x)</em></li>
<li>We got <em>f(x) ϵ {0,1}</em> and _is_even(x) =is<em>even(f(x))</em>. QED.</li>
</ul>
<h3>Implementation</h3>
<p>Let’s try to implement this algorithm using a neural network over a small domain. We start again by defining the data.</p>
<pre><code>X = [[i] for i in range(0, 16)]
Y = [z[0] % 2 for z in X]</code></pre>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1YqzI9JUfHpKIebAvWDEJxA.png" alt="is_even data and labels on a small domain [0, 15]" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1YqzI9JUfHpKIebAvWDEJxA.png 547w, https://towardsdatascience.com/wp-content/uploads/2024/09/1YqzI9JUfHpKIebAvWDEJxA-300x237.png 300w" /><figcaption>is_even data and labels on a small domain [0, 15]</figcaption></figure>
<p>Because the domain contains 2⁴ integers, we need to use 6 neurons. 5 for _f_1∘ f_1∘ f_2 ∘ f_4∘ f<em>8,</em> + 1 output neuron. Let’s build the network and hardwire the weights</p>
<pre><code>def create_sequential_model(layers_list = [1,2,2,2,2,2,1]):
  layers = []
  for i in range(1, len(layers_list)):
      layers.append(nn.Linear(layers_list[i-1], layers_list[i]))
      layers.append(nn.ReLU())
  return nn.Sequential(*layers)
# This weight matrix implements |ABS| using ReLU neurons.
# |x-b| = Relu(-(x-b)) + Relu(x-b)
abs_weight_matrix = torch_tensor([[-1, -1],
                                  [1, 1]])
# Returns the pair of biases used for each of the ReLUs.
get_relu_bias = lambda b: torch_tensor([b, -b])
d = model.state_dict()
d['0.weight'], d['0.bias'] = torch_tensor([[-1],[1]]), get_relu_bias(8)
d['2.weight'], d['2.bias'] = abs_weight_matrix, get_relu_bias(4)
d['4.weight'], d['4.bias'] = abs_weight_matrix, get_relu_bias(2)
d['6.weight'], d['6.bias'] = abs_weight_matrix, get_relu_bias(1)
d['8.weight'], d['8.bias'] = abs_weight_matrix, get_relu_bias(1)
d['10.weight'], d['10.bias'] = torch_tensor([[1, 1]]), torch_tensor([0])
model.load_state_dict(d)
model.state_dict()</code></pre>
<p>As expected we can see that this model makes a perfect prediction on [0,15]</p>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/0aEthaUqieHZVE3NS.png" alt="" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/0aEthaUqieHZVE3NS.png 547w, https://towardsdatascience.com/wp-content/uploads/2024/09/0aEthaUqieHZVE3NS-300x237.png 300w" /></figure>
<p>And, as expected, it doesn’t generalizes to new data points</p>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/1pI5fpiiov785CSBjSJaPTg.png" alt="" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/1pI5fpiiov785CSBjSJaPTg.png 543w, https://towardsdatascience.com/wp-content/uploads/2024/09/1pI5fpiiov785CSBjSJaPTg-300x239.png 300w" /></figure>
<p>We saw that we can hardwire the model, but would the model converge to the same solution using gradient descent?</p>
<figure><img src="https://towardsdatascience.com/wp-content/uploads/2024/09/0Q_GuzNClkdYhcxuv.png" alt="" srcset="https://towardsdatascience.com/wp-content/uploads/2024/09/0Q_GuzNClkdYhcxuv.png 547w, https://towardsdatascience.com/wp-content/uploads/2024/09/0Q_GuzNClkdYhcxuv-300x237.png 300w" /></figure>
<p>The answer is – not so easily! Instead, it is stuck at a local minimum – predicting the mean.</p>
<p>This is a known phenomenon, where gradient descent can get stuck at a local minimum. It is especially prevalent for non-smooth error surfaces of highly nonlinear functions (such as is_even).</p>
<p>More details are beyond the scope of this article, but to get more intuition one can look at the many works that investigated the classic XOR problem. Even for such a simple problem, we can see that gradient descent can struggle to find a solution. In particular, I recommend Richard Bland’s short <a target="_blank" href="https://www.cs.stir.ac.uk/~kjt/techreps/pdf/TR148.pdf">book</a> "Learning XOR: exploring the space of a classic problem" – a rigorous analysis of the error surface of the XOR problem.</p>
<h3>Final Words</h3>
<p>I hope this article has helped you understand the basic structure of small neural networks. Analyzing Large Language Models is much more complex, but it’s an area of research that is advancing rapidly and is full of intriguing challenges.</p>
<p>When working with Large Language Models, it’s easy to focus on supplying data and computing power to achieve impressive results without understanding how they operate. However, <a target="_blank" href="https://towardsdatascience.com/tag/interpretability/" title="Interpretability">Interpretability</a> offers crucial insights that can help address issues like fairness, inclusivity, and accuracy, which are becoming increasingly vital as we rely more on LLMs in decision-making.</p>
<p>For further exploration, I recommend following the <a target="_blank" href="https://www.alignmentforum.org/">AI Alignment Forum</a>.</p>
<p>*All the images were created by the author. The intro image was created using ChatGPT and the rest were created using Python libraries.</p></div>